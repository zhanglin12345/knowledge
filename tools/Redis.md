# 缓存的常用模式
1. Write through。有个单独的cache层，来保证cache中的key保存入DB
   <img src="/Users/linzhang/Documents/Java/knowledge/tools/image/redis-1.png" alt="avatar" style="zoom:100%;" />
   
2. Write around。application直接写入DB，在read的时候才放入缓存，与read through一起使用
  
  <img src="/Users/linzhang/Documents/Java/knowledge/tools/image/redis-2.png" alt="avatar" style="zoom:100%;" />
  
3. Read through

   <img src="/Users/linzhang/Documents/Java/knowledge/tools/image/redis-3.png" alt="avatar" style="zoom:100%;" />

4. Write behind. 当缓存达到一定数量时，更新到DB

   <img src="/Users/linzhang/Documents/Java/knowledge/tools/image/redis-4.png" alt="avatar" style="zoom:100%;" />

5. Cache aside. 当缓存中无key时，从数据库中获取并更新至缓存

   <img src="/Users/linzhang/Documents/Java/knowledge/tools/image/redis-5.png" alt="avatar" style="zoom:100%;" />

6. Write back. 当cache中有一定积累后，才更新到数据库

<img src="/Users/linzhang/Documents/Java/knowledge/tools/image/redis-6.png" alt="avatar" style="zoom:100%;" />

# DataType
## String

| 作用     | 用于存储字符串                                           |
| -------- | -------------------------------------------------------- |
| 存储结构 | 数组类似的结构。预分配冗余空间的方式来减少内存的频繁分配 |
| 特殊使用 | 如果valude是整数，可以用incr命令来自增设定的value        |

## list

| 作用     | 用于存储列表，排序按照插入顺序               |
| -------- | -------------------------------------------- |
| 存储结构 | 链表类似的结构                               |
| 优点     | 插入删除很快                                 |
| 缺点     | 因为是链表，所以查询复杂度是O(n)             |
| 特殊使用 | 队列/栈           Rpush/lpush      Rpop/lpop |

## hash 

| 作用     | 用于存储key   value的无序字典                                |
| -------- | ------------------------------------------------------------ |
| 存储结构 | 类似HashMap的结构，数组+链表。哈希碰撞时放入链表             |
| 优点     | 与java的rehash不同，redis使用了渐进式rehash。也就是说，同时保留老的hash和新的hash，等到rehash完成，删除老hash |
| 缺点     | Hash的存储消耗要高于单个字符串存储                           |
| 特殊使用 | 可以使用hincrby来自增value                                   |

## set

| 作用     | 用于存储unique   value的无序set |
| -------- | ------------------------------- |
| 存储结构 | 类似于hashset的结构。           |
| 优点     | 跟list相比，不会有重复          |

## Sorted Set

| 作用     | 用于存储value的有序set,   sorted by score                    |
| -------- | ------------------------------------------------------------ |
| 存储结构 | 类似于sortedSet和hashmap的结合体                             |
| 作用     | 用score来range拿到range内的value     用index来range拿到value |
| 优点     | value是唯一的     指定sort的权重score                        |

## 位图bitfield

| 作用     | 存储bit |
| -------- | ------- |
| 存储结构 | bit     |

## HyperLogLog

| 作用           | 用于当存储量非常大，但是只需要进行count unique的情况，用于概率求unique   count，有较小的误差，但是存储量非常小 |
| -------------- | ------------------------------------------------------------ |
| 存储结构       | 类似于sortedSet和hashmap的结合体                             |
| 为什么不用incr | 因为incr不能去重呀                                           |
| 缺点           | 不能知道某个value是否已经被添加过了                          |

## Streams

## Geo

| 作用     | 用于当存储量坐标                                             |
| -------- | ------------------------------------------------------------ |
| 存储结构 | 就是redis的sorted   set                                      |
| 注意     | Geo其实就是个zset，所以zset是不会默认拆分到多个节点上的。如果数据量过大的话，可以按照地域手动拆分key。但是这样拆分之后就要考虑reduce的问题。 |

# 分布式锁

对于single instance，redis已经有了自己的set+expire! Set [key] [value] ex [seconds] nx
对于分布式cluster,
要使用对应的客户端分布式锁库来完成，比如redlock，其原理是向所有节点发送锁请求，还挺麻烦的

# 扩展模块

4.0之后才支持扩展，其中有：

布隆过滤器
Redis cell 限流

# Keys和scan

| keys的作用 | 模糊查找条件匹配的key                                        |
| ---------- | ------------------------------------------------------------ |
| 缺点       | 当满足条件的key数量很多时，redis的单线程就一直在处理这条命令，造成了其它命令无法得到执行     不能limit返回的结果 |

| scan的作用 | 模糊查找条件匹配的key                                        |
| ---------- | ------------------------------------------------------------ |
| 优点       | 分步骤进行，不会阻塞线程     提供limit限定每次服务器查询的数量 |

# 持久化

## 快照

| 作用 | 把redis内存中的数据快照持久化到磁盘                          |
| ---- | ------------------------------------------------------------ |
| 原理 | redis的进程folk出一个子进程，从而分离了写和读。redis的父进程和子进程是共享内存数据的，子进程就可以读取内存中的数据并持久化到磁盘。与此同时，父进程继续写入内存，此时使用copy on write技术，在写入某个页面时，copy了一个页面并写入，这样就不会影响到子进程读取内存快照。 |

## AOF增量日志

redis的从节点没有客户端请求，只是作为备份。所以操作主要是从节点来进行

| 作用    | 存储redis的每条指令序列。                                    |
| ------- | ------------------------------------------------------------ |
| 原理    | 当指令处理成功后，存储指令到内存，内存隔一段时间持久化到磁盘。所以恢复时，通过重放来恢复数据。 |
| AOF瘦身 | 时间长了指令序列会越来越长，导致恢复时非常慢，这时需要bgrewriteaof指令对AOF日志进行瘦身。   开辟一个子进程对AOF日志遍历，去除不必要的指令。 |
| Fsync   | 强制把内存持久化到磁盘；也可以指定周期来fsync，也可以用不调用fsync。如果周期太短，导致性能差；如果周期太长，又容易丢失数据。随意要根据情况。 |

## 混合持久化

| 作用 | 将rdb和AOF存放在一起。redis重启时，先加载rdb，再重放AOF。 |
| ---- | --------------------------------------------------------- |
| 原理 |                                                           |

# Redis benchmark
redis自带性能测试工具benchmark

# Pipeline
只由客户端提供的技术。比普通指令的性能大大提升
	1. 客户端将redis指令存入socket的send buffer中
	2. 由操作系统将send buffer发送至网卡，网卡再将数据经过路由发送至redis服务器的网卡
	3. 服务器操作系统将网卡的数据放入socket的recv buffer中
	4. redis服务进程read from recv buffer并对消息进行处理
	5. redis服务进程用write将响应结果写入socket的send buffer中
	6. 服务器操作系统将send buffer发送至网卡，网卡经过路由发送给客户端
	7. 客户端操作系统将网卡的数据放入recv buffer中
	8. 客户端进程调用read从buffer中把消息取出给上层业务逻辑处理

# 事务
1. redis的事务不具备“原子性“，仅仅是为了打包命令一起执行，然后一起返回结果给客户端
2. 所以redis的事务不支持回滚，如果中间有命令出错，仍然执行一下条命令
3. 当运行到exec才真正执行所有命令
4. redis的事务里，每次发送命令，都会有一次客户端-服务端的来回。所以如果是大批量命令，最好使用管道
5. redis的事务对当前客户端启动的thread有效，当前thread不能启动两次multi，也就是没有nested multi
6. Watch --- watch是乐观锁
7. watch只能在事务multi之前执行

# 主从同步

## 同步	
1. 主从同步是异步的。所以redis保证最终一致性
2. redis支持主从同步和从从同步，以减轻主节点的负担
3. Slave默认是readonly的。所有的客户端默认是prefer master的

## 防止同步消息丢失	
这两个配置要慎用，默认都没有开启，因为跟可用性相关，为了复制到slave，master都不提供服务了，真是。。。
	1. Min-slave-to-write 1 表示master至少有一个slave在进行复制，否则就停止对外服务，丧失可用性
	2. Min-slaves-max-lag 10 表示10s没有收到slave的反馈，复制异常，那么master就对外停止服务，丧失可用性

## 增量同步	
1. 增量同步：redis同步的是指令流。主节点将指令流存储在一个定长的环形数组中（本地内存），然后异步将环形数组中的指令同步到从节点。主节点执行指令流，然后告知主节点执行到哪里了（偏移量）
2. . 因为是环形数组，旧的指令会被新的指令覆盖。如果旧的指令没有同步给从节点，那么就需要快照同步
3. 设置合适的buffer大小，可以避免覆盖未同步的指令
## 快照同步	
步骤
1. 主节点从内存中读取快照并且持久化到磁盘
2. 然后将磁盘文件传送给子节点
3. 从节点从磁盘读取数据，并全量加载
4. 与此同时，环形数组也在写入指令流
5. 当从节点完成快照同步，就开始增量同步
6. 如果在快照同步完成之后发现，环形数组又被覆盖了，那么就重新来一次。所以环形数组buffer的大小很重要
  
## 快照同步发生的条件
	1. 新增子节点
	2. 增量同步失败
	异步
	异步进行。不影响主线程存取
	注意
	主节点把快照持久化到磁盘时，fsync被推迟执行

## 无盘复制
与快照同步类似，缺少的环节是无须持久化磁盘。好处是少了IO，而且不影响fsync。坏处是still EXPERIMENTAL CURRENTLY
## 强制同步复制
用wait命令强制同步复制。好处是较大可能保证强一致性，坏处是很大影响了master的性能

# Sentinel

| 作用           | 监控主从节点。当主节点不可用，切换为从节点。     客户端连接至sentinel，sentinel转发给主节点。 |
| -------------- | ------------------------------------------------------------ |
| Sentinel的主从 | 客户端内存中有sentinel的主从所有地址     如果主节点变更，比如不可用，就选择从地址     如果主节点更换为从节点，那么就得到read only         error，于是变更地址 |

# Redis cluster
## 集群化方案
1. 客户端分片 --- 由业务来分片。不推荐
2. 代理分片 ----- Codis. 缺点是不支持的命令有一堆，优点是比redis cluser要更方便，并提供dashboard管理
3. Redis cluster


## Redis Cluster的请求方式
1. Redis cluster将数据划分为16384个槽位，每个节点管理其中一部分槽位
2. 客户端来连接集群时，得到一份槽位配置信息，那么当查找某个key时，可以直接定位目标节点
3. 当客户端请求节点时，该节点发现key并不属于自己管理，那么将回复“moved 正确目标节点”，供客户端重新发起请求到目标节点。客户端收到回复，会发起请求到目标节点，并且更新槽位信息

## Redis cluster的槽位迁移

| 现状               | Redis提供了redis-trib供运维人员手动调整槽位，Codis提供了UI更方便的迁移。redis的策略就是提供小而全的工具，而不是提供全方位的dashboard。所以这点是不是可以找工具来完成？ |
| ------------------ | ------------------------------------------------------------ |
| 迁移步骤           | 同步一个key一个key迁移，当目标节点复制完成，源节点删除key     如果迁移中断，恢复后继续迁移 |
| 迁移中客户端的访问 | 在迁移过程中客户端还是访问老节点，如果老节点中存在，那么返回内容     如果老节点中不存在，而且这个key就是属于老节点的槽，那么老节点会回复“ask         新节点地址”由客户端访问新节点 |

# 限制

1. 只有database 0
2. 不支持事务
3. rename方法非原子性。因为需要迁移
4. mget方法会慢很多，因为要map and reduce

## Failover

1. Redis cluster是自动完成主从切换的，不需要sentinel
2. 网络抖动时，在到cluster-node-timeout规定的时间后，才认为是失联
3. Redis cluster是去中心化的。当一个node认为某个node失联了，那么就是possibly fail；于是就会发通知询问其它node，当集群中大多数node都认为该node失联，那么才是真正的fail。fail后就会发生主从切换
   如果主和从都不可用，那么集群将不可用.
4. 有个配置项cluster-require-full-coverage，当某些节点主从挂掉，集群仍然可用，怎么配置未知

# 诊断

Info指令得到redis的诊断信息
monitor指令得到redis的执行命令

# 过期key策略

| 存储             | redis将所有设置了expire的key放在一个独立的字典中             |
| ---------------- | ------------------------------------------------------------ |
| 定时扫描         | 没100ms定时扫描设置了expire的字典，采用了贪心策略。随机选择，超过了阈值就25ms后重复扫描；如果没有超过阈值，就100ms后扫描。     所以要注意，别有大量key一起过期。如果有业务需求，就在expire时间上加上随机时间 |
| 惰性删除         | 当客户端请求redis时，发现该key已经过期，那么就删除           |
| 从节点的过期策略 | 当master删除节点后，发送删除指令给slave                      |

# LRU

当redis内存超出物理内存的限制时，内存中的数据会频繁的与磁盘交换，导致性能急剧下降。所以要配置redis内存的限制策略

| Noeviction（默认） | 超出后拒绝写入                  |
| ------------------ | ------------------------------- |
| Volatile-lru       | 最少使用的，设置了过期时间的key |
| Volatile-ttl       | ttl最少的被淘汰                 |
| Volatile-random    | 随机淘汰设置了过期时间的key     |
| Allkeys-lru        | 最少使用的所有key               |
| Allkeys-random     | 随机淘汰所有key                 |

# 删除策略

1. del会直接删除key并且释放内存，小对象非常快，但是大对象就比较慢
2. unlink命令可以“断掉”key，从而由后台进程删除该key。速度快
3. flush指令也可以加async来异步删除

# 安全

| 危险指令  | 如keys，flush指令。可以rename来禁止             |
| --------- | ----------------------------------------------- |
| 暴露端口  | 不应该暴露端口到公网上                          |
| lua脚本   | 禁止lua脚本由用户输入的内容生成                 |
| redis角色 | 以普通用户启动redis，这样就拿不到root权限       |
| SSL支持   | redis本身不支持ssl，可以用spiped工具来做SSL代理 |

# 缓存穿透和缓存雪崩

1. 缓存穿透是指redis中没有该缓存，导致大量请求到数据库；在数据库请求处加锁，同一时间只有一个或者几个线程进入查询，等待的线程拿到锁之后，先查询缓存，如果没有再查询数据库。
2. 缓存雪崩是指缓存在一个时间点集中失效。比如大量的key的失效时间是一致的。解决方法是让key的失效时间不一致，增加随机几秒或者几百毫秒的失效。