# 什么是GC
1. Garbage collector，顾名思义，就是回收垃圾。垃圾就是app不再使用的内存。
2. 一般来说，GC会扫描堆，找到不再被使用的对象，标记并且挪到不同的“代”，最后进行回收和内存整理。

# G1 GC
## 回收步骤

## 优点
1. 压缩新生代和老年代内存，但是时间很短
2. 在java 11中可以将big object设置在young GC中回收

## 与其它收集器的不同
目前来看，比其它收集器要更加的“自动化”，设置的参数是目标，而不是“过程”。

## 主要设置
1. Maximum pause time.  -XX:MaxGCPauseMillis 每次GC的时间，都会低于这个值。JVM是通过调整堆的大小来实现的
2. Throughput goal. -XX:GCTimeRatio。 GC停顿时间占比。

## 优化建议
1. 如果GC时间过短，heap size很小，那么可以增加MaxGCPauseMillis 
2. 如果GC时间很长，heap size很大，可以适当减少heap size，增多instance的数量

## 特点

# CMS
## 回收步骤

## 特点
在老版本的java中，是低延迟的首选。
默认情况下，不压缩老年代。
需要指定多少次full gc后，才回收老年代。导致内存使用量很大。尤其是short lived big object的情况下

# 案例1，大量的老生代对象
1. 进行文件迁移时，由于产生了大量的大对象，大对象直接分配在老生代，产生了大量的碎片，导致OOM异常。
2. 将大对象按比例切割为固定大小的块，4M，1M，512K等。高于1M的对象在老生代产生固定大小的碎片，从而被重复利用；低于1M的对象分配在新生代，被GC回收和整理。

# 案例2，大量的新生代对象
1. web服务器，大量请求产生了大量朝生夕死的小对象。Java 8默认的parallel gc，新生代很小，很快就满了，老年代却空空如也。
2. 在java 8中，调整为CMS GC，并且新生代占了整个堆的3/4。新生代迁移到老年代的存活次数被调至最高
3. 堆的大小设置为2g，这样每次GC占用的时间非常小。多个实例保证了throughput
4. 在java11中，使用G1 gc。根据测试设置了合适的MaxGCPauseMillis，G1 gc自动调整各代的大小。无须手动配置
